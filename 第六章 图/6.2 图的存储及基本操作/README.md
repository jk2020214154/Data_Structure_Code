#### 邻接矩阵法(适合稠密图)

结点数为 $n$的图 $G=(V,E)$的邻接矩阵 $A$是 $n\times n$的,将 $G$的顶点编号为 $v_1,v_2,\cdots,v_n$,则

![](https://cdn.acwing.com/media/article/image/2023/09/03/85276_8b125b254a-20230903163954.png) 

对于**带权图**,若顶点 $v_i$和 $v_j$之间有边相连,则邻接矩阵中对应项存放着该边**对应的权值**;若顶点 $v_i$和 $v_j$不相连,则通常用 $\infty$来代表着两个顶点间不存在边,则

![](https://cdn.acwing.com/media/article/image/2023/09/03/85276_5182ad994a-20230903164532.png) 

图的邻接矩阵存储结构如下:

```cpp
#define MaxVertexNum 100//顶点数目的最大值
#define inf (INT_MAX)//无穷大

typedef char VertexType;//顶点的数据类型
typedef int EdgeType;//带权图中边上权值的数据类型

typedef struct{
    VertexType Vex[MaxVertexNum];//顶点表
    EdgeType Edge[MaxVertexNum][MaxVertexNum];//邻接矩阵,边表
    int vexnum,arcnum;//图的当前顶点数,图的边数/弧数
}MGraph;
```

![](https://cdn.acwing.com/media/article/image/2023/09/03/85276_808b7fa44a-20230903164713.png) 

* **无向图**的邻接矩阵一定是一个**对称矩阵**(并且唯一),对规模特大的邻接矩阵可采用**压缩存储**(只存储上(或下)三角矩阵的元素)
* 对于**无向图**,邻接矩阵的第 $i$**行**(或第 $i$**列**)非零元素(或非 $\infty$元素)的个数是**顶点 $i$的度** $TD(v_i)$
* 对于**有向图**,邻接矩阵的第 $i$**行**非零元素(或非 $\infty$元素)的个数是**顶点 $i$的出度** $OD(v_i)$;第 $i$**列**非零元素(或非 $\infty$元素)的个数是**顶点 $i$的入度** $ID(v_i)$
* 用邻接矩阵存储图,可容易确定图中**任意两个顶点之间是否有边相连**.要确定图中有多少条边,必须按行、按列对每个元素进行检测,所花费的时间代价很大
* **稠密图**适合使用邻接矩阵的存储表示,空间复杂度为 $O( \left| V \right|  ^{2} )$
* 设图 $G$的邻接矩阵为 $A$,则 $A^{n}$的元素 $A^{n}[i][j]$等于由顶点 $i$到顶点 $j$的长度为 $n$的**路径的数目**

#### 邻接表法(适合稀疏图和其他)

当一个图为**稀疏图**,使用`邻接矩阵法`会**浪费大量的存储空间**,而图的`邻接表法`结合了**顺序存储和链式存储**的方式,大大减少不必要的浪费.

对图 $G$中每个顶点 $v_i$建立一个单链表,第 $i$个单链表中的结点表示依附于顶点 $v_i$的边(在有向图表示以顶点 $v_i$为尾的弧),这个单链表是顶点 $v_i$的**边表**(对有向图称为**出边表**).边表的头指针和顶点的数据信息采用顺序存储(称为**顶点表**),在邻接表中存在两种结点:`顶点表结点`和`边表结点`.

![](https://cdn.acwing.com/media/article/image/2023/09/03/85276_7f650ceb4a-20230903171549.png)

**顶点表结点**由顶点域 $data$和指向第一条邻接边的指针 $firstarc$构成,边表(邻接表)结点由邻接点域 $adjvex$和指向下一条邻接边的指针域 $nextarc$构成.

图的邻接表存储结构如下:

```cpp
#define MaxVertexNum 100//顶点数目的最大值

typedef char VertexType;//顶点的数据类型
typedef int InfoType;//带权图中边上权值的数据类型

typedef struct ArcNode{//边表结点
    int adjvex;//该弧所指向的顶点的位置
    struct ArcNode *next;//指向下一条弧的指针
    //InfoType info;//网的边权值
}ArcNode;

typedef struct VNode{//顶点表结点
    VertexType data;//顶点信息
    ArcNode *first;//指向第一条依附该顶点的弧的指针
}VNode,AdjList[MaxVertexNum];

typedef struct{//邻接表
    AdjList vertices;//邻接表
    int vexnum,arcnum;//图的当前顶点数,图的边数/弧数
}ALGraph;
```

 ![](https://cdn.acwing.com/media/article/image/2023/09/03/85276_a1a187c34a-20230903171646.png) 

* 若 $G$为**无向图**,则需要的存储空间为 $O( \left| V \right| + 2\times \left| E \right| )$;若 $G$为**有向图**,则需要的存储空间为 $O( \left| V \right| + \left| E \right| )$.前者的倍数 $2$由于无向图中,**每条边在邻接表中出现了两次**
* 对于**稀疏图**,采用邻接表表示将极大地节省存储空间
* 在邻接表中,给定一顶点,可容易地找出它的**所有邻边**,只需要读取它的邻接表;而在邻接矩阵中,相同的操作需要扫描一行,时间复杂度为 $O(n)$.若要确定给定两个**顶点间是否存在边**,则在邻接矩阵中可立刻查到;而在邻接表中需要再相应结点对应的边表中查找另一结点,效率极低.
* 在有向图的邻接表表示中,求一个给定顶点的出度只需要计算其邻接表中的结点个数;但求其顶点的入度则需要遍历全部的邻接表.此时可采用**逆邻接表**的存储方式来加速求解给定顶点的入度.
* 图的邻接表表示**不唯一**,在每个顶点对应的单链表中,各边结点的链接次序可以是任意的,它取决于建立**邻接表的算法及边的输入次序**

![](https://cdn.acwing.com/media/article/image/2023/09/03/85276_61a8aa964a-20230903193039.png) 

#### 十字链表(用于有向图)

十字链表是有向图的一种链式存储方式.

![](https://cdn.acwing.com/media/article/image/2023/09/03/85276_c91299fe4a-20230903193349.png) 

**弧结点**中有 $5$个域： $tailvex$和 $headvex$两个域分别指示弧尾和弧头这两个顶点的编号; $hlink$域指向弧头相同的下一个弧结点; $tlink$域指向弧尾相同的下一个弧结点; $info$域存放该弧的相关信息.**弧头相同的弧在同一个链表上,链尾相同的弧也在同一个链表上**

**顶点结点**中有 $3$个域, $data$域存放该顶点的数据信息,如顶点名称; $firstin$域指向以该顶点为弧头的第一个弧结点; $firstout$域指向以该顶点为弧尾的第一个弧结点.

![](https://cdn.acwing.com/media/article/image/2023/09/03/85276_d073c9c34a-20230903194114.png) 

在十字链表中,既容易找到 $v_i$为尾的弧,又容易找到 $v_i$为头的弧,故容易求得**顶点的出度和入度**.图的十字链表表示依然是**不唯一**的,但一个十字链表表示**确定一个图**.

#### 邻接多重表(用于无向图)

邻接多重表是无向图的另一种链式存储结构.在邻接表中,容易求得顶点和边的各种信息,但在邻接表中求两个顶点之间是否存在边而对边执行删除等操作时,需要分别在两个顶点的边表中遍历,效率极低.

与十字链表类似,在邻接多重表中,每条边用一个结点表示,如下:

![](https://cdn.acwing.com/media/article/image/2023/09/03/85276_2f8abd824a-20230903195059.png) 

其中, $mark$为标志域(现王道书中无 $mark$域),用于标记该条边是否被搜索过; $ivex$和 $jvex$为该边依附的两个顶点在图中的位置; $ilink$指向下一条依附于顶点 $ivex$的边; $jlink$指向下一条依附于顶点 $jvex$的边, $info$指向和边相关的各种信息的指针域.

每个顶点用一个结点表示, $data$域存储该顶点的相关信息, $firstedge$域指向第一条依附于该顶点的边.

![](https://cdn.acwing.com/media/article/image/2023/09/03/85276_e1c047824a-20230903195602.png) 

对无向图,其邻接多重表和邻接表的差别仅在于,同一条边在邻接表中用两个结点表示,而在邻接多重表中只有一个结点.

![](https://cdn.acwing.com/media/article/image/2023/09/03/85276_42a1888b4a-20230903195813.png) 



![](https://cdn.acwing.com/media/article/image/2023/09/03/85276_9bc173cb4a-20230903200111.png) 

