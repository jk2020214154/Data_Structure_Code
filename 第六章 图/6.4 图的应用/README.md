#### 最小生成树

对于一个带权连通无向图 $G=(V,E)$,生成树不同,每棵树的权(即树中所有边上的权值之和)也可能不同,设 $\Re$为 $G$的所有生成树的集合,若 $T$为 $\Re$中边的权值之和最小的那棵生成树，则 $T$称为 $G$的最小生成树( $MST$).

![](https://cdn.acwing.com/media/article/image/2023/10/21/85276_8ca3aaff6f-20200506151404489.png) 

最小生成树的性质：

* 最小生成树不是唯一的,即**最小生成树的树形不唯一**, $\Re$中可能有多个最小生成树.当图 $G$中各边权值互不相同时, $G$的最小生成树是唯一的;若无向连通图 $G$的边数比顶点数少 $1$,即 $G$本身是一棵树时,则 $G$的最小生成树就是它本身.
* 最小生成树的边的权值之和总是唯一的,虽然最小生成树不唯一,但其对应的边的**权值之和总是唯一的且是最小**的.
* 最小生成树的边数为顶点数减 $1$.

##### Prim算法

该算法的时间复杂度为 $O(\left| V \right|^2)$,不依赖于 $\left| E \right|$,它可通过使用**优先队列**把时间复杂度优化为 $O(\left| E\right| \log_{2}{\left| V \right|})$,它适用于求解**边稠密**的图.

该算法可以称为**加点法**,每次迭代选择代价最小的边对应的点,将满足条件的加入到最小生成树中.算法从某个顶点 $s$出发,逐渐覆盖整个连通网的所有顶点.

1. 图的所有顶点集合为 $V$,初始令顶点的集合 `u={s}`,剩余的顶点集合 $v=V-u$;
2. 在两个集合 $u,v$能够组成的边中,选择一条代价最小的边 $e=(u_0,v_0)$,并把这条边加入到最小生成树中,把 $v_0$加入到集合 $u$中;
3. 重复上述步骤,直到最小生成树有 $n-1$条边或者有 $n$个顶点为止.

![](https://cdn.acwing.com/media/article/image/2023/10/21/85276_093e28c86f-20231021174112.png) 

##### Kruskal算法

该算法的时间复杂度为 $O(\left| E \right| \log_{2} \left| E \right|)$,适用于**边稀疏而顶点较多**的图.

该算法可以称为 **加边法** ,初始化最小生成树边数为 $0$,每迭代一次选择一条满足条件的最小代价边,加入到最小生成树的边集合中.

1. 把图中的所有边按代价从小到大排序;
2. 把图中的 $n$个顶点看成独立的 $n$棵树组成的森林;
3. 按权值从小到大选择边,所选的边连接的两个顶点 $u_i,v_i$属于两棵不同的树,使之成为最小生成树的一条边,并将这两棵树合并作为一棵树(**此处用到并查集**);
4. 重复 $(3)$,直到所有顶点都在同一棵树上或者有 $n-1$条边为止.

![](https://cdn.acwing.com/media/article/image/2023/10/21/85276_6f21cfde6f-20231021172957.png) 

#### 最短路径

从图中**某个顶点**出发到达**另外一个顶点的所经过的边的权重和最小的一条路径**，称为最短路径.

单源最短路径问题(`Single Source Shortest Path`, $SSSP$问题),给定一张有向图 $G=(V,E)$, $V$是点集, $E$是边集, $\left| V \right|=n$, $\left| E\right|=m$,结点以 $[1,n]$之间的连续整数编号, $(x,y,z)$描述一条从 $x$出发,到达 $y$,长度为 $z$的有向边.设 $1$号点为起点,求长度为 $n$的数组 $dist$,其中 $dist[i]$表示从 $1$到结点 $i$的最短路径的长度.

##### Dijkstra算法

 $Dijkstra$算法步骤如下：

1. 初始化起点 $start$的 $dist[start]=0$,其余结点的 $dist$的值为**正无穷大**( $+ \infty$);
2. 找出一个**未被标记**的且 $dist[x]$**最小的结点** $x$,然后标记结点 $x$;
3. 扫描结点 $x$的所有出边 $(x,y,z)$,若 $dist[y]>dist[x]+z$,则使用 $dist[x]+z$更新 $dist[y]$;
4. 重复上述 $2 \sim 3$两个步骤,直到所有结点都被标记.

 $Dijkstra$算法基于贪心的思想,它只适用于**所有边的长度都是非负数**的图.当边长 $z$都是非负数时,全局最小值不可能再被其他结点更新,故在第一步选出的结点 $x$必然满足: $dist[x]$已经是起点到 $x$的最短路径.我们不断选择全局最小值进行标记和扩展,最终可得到起点 $start$到每一个结点的最短路径的长度.

> **举例**：
> 
> * 用一个 $dis$数组保存源点到其余各个结点的距离, $dis[i]$表示源点到结点 $i$的距离,初始时 $dis$数组的各个元素为无穷大( $+ \infty$);用一个数组 $flag$标记是否找到了源点到该结点的最短距离,初始时 $flag$数组的各个元素清为 $0$;
> 
> ![](https://cdn.acwing.com/media/article/image/2023/10/21/85276_458f871770-20231021211749.png) 
> 
> * 假设源点是 $1$,将其 $dis[1]$设置为 $0$(源点到源点距离为 $0$);
> 
> ![](https://cdn.acwing.com/media/article/image/2023/10/21/85276_9671d87670-20231021212008.png) 
> 
> * 遍历 $dis$数组,找到一个结点,这个结点是：**没有确定最短路径的结点中距离源点最近的点**.假设该结点编号为 $i$,此时就找到了源点到该结点的最短距离, $flag[i]$设置为 $1$;
> 
> ![](https://cdn.acwing.com/media/article/image/2023/10/21/85276_104ee59f70-20231021213010.png)
> 
> * 遍历 $i$所有可以到达的结点 $j$,如果 $dis[j]>dis[i]+w[i][j]$( $w[i][j]$表示 $i \to j$的距离),则更新 $dis[j]$为 $dis[i]+w[i][j]$;
> 
> ![](https://cdn.acwing.com/media/article/image/2023/10/21/85276_7b05aa6b70-20231021213341.png)
> 
> * 重复 $3 \sim 4$步骤,直到所有结点的 $flag$都标记为 $1$.
> 
> ![](https://cdn.acwing.com/media/article/image/2023/10/21/85276_c0bef21f70-20231021213511.png) 
> 
> ![](https://cdn.acwing.com/media/article/image/2023/10/21/85276_c51d93f470-20231021213522.png) 
> 
> ![](https://cdn.acwing.com/media/article/image/2023/10/21/85276_c723e7fa70-20231021213532.png) 
> 
> * 此时 $dis$数组中,就保存了源点到其余各个结点的最短距离.
> 
> ![](https://cdn.acwing.com/media/article/image/2023/10/21/85276_ee2c960d70-20231021213656.png) 

##### Floyd算法

为了求出图中任意两点间的最短路径,当然可以把每个点作为起点,求解 $N$次单源最短路径问题.不过,在任意两点间最短路问题中,图一般比较稠密.使用 $Floyd$算法可以在 $O(n^3)$的时间内完成求解.

1. 初始化邻接矩阵(二维数组) $dist[][]$,其中 $dist[i][j]$表示顶点 $i$到顶点 $j$的权值,若顶点 $i$和顶点 $j$不相邻,则 $dist[i][j]=+ \infty$,若顶点 $i$等于顶点 $j$,则 $dist[i][j]=0$;
2. 以第 $1$个顶点为中介点,若 $dist[i][j]>dist[i][1]+dist[1][j]$,更新 $dist[i][j]$;
3. 依次以第 $2,3,\cdots,k,\cdots,n$个顶点为中介点,若 $dist[i][j]>dist[i][k]+dist[k][j]$,更新 $dist[i][j]$.

**举例**：

> ![](https://cdn.acwing.com/media/article/image/2023/10/22/85276_4b4b7e2270-20231022150312.png) 
> 
> ![](https://cdn.acwing.com/media/article/image/2023/10/22/85276_5c08171770-20231022150323.png) 
> 
> ![](https://cdn.acwing.com/media/article/image/2023/10/22/85276_4f93ef5170-20231022150331.png) 
> 
> ![](https://cdn.acwing.com/media/article/image/2023/10/22/85276_53c2b1b270-20231022150339.png) 
> 
> ![](https://cdn.acwing.com/media/article/image/2023/10/22/85276_62a4fae970-20231022150349.png) 
> 
> ![](https://cdn.acwing.com/media/article/image/2023/10/22/85276_65c801b270-20231022150402.png) 

设 $dist[k,i,j]$表示`经过若干个编号不超过k的结点`,从 $i$到 $j$的最短路长度.该问题可划分为两个子问题,经过编号不超过 $k-1$的结点从 $i$到 $j$,或者从 $i$到 $k$,再到 $j$,可得:

$\color{Red}{dist[k,i,j]=min(dist[k-1,i,j],dist[k-1,i,k]+dist[k-1,k,j])}$

初值为 $dist[0,i,j]=A[i,j]$,其中 $A$为该图的邻接矩阵.

可以看到, $Floyd$算法的本质是**动态规划**, $k$是阶段,应置于最外层循环中, $i$和 $j$是附加状态,应置于内层循环.故不应该采用 $i,j,k$的顺序执行循环,会得到错误的答案. $k$这一维可省略(三维变成二维),最初,可直接用 $dist$保存邻接矩阵,然后执行动态规划的过程.当最外层循环到 $k$时,内层有转移方程: $\color{Red}{dist[i,j]=min(dist[i,j],dist[i,k]+dist[k,j])}$.

#### 有向无环图描述表达式

若一个有向图中不存在环,则称为有向无环图,简称 $DAG$图.

![](https://cdn.acwing.com/media/article/image/2023/10/22/85276_db9e8b6070-20231022153623.png) 

将表达式转化为有向无环图步骤:

1. 把各个操作数不重复地排成一排;
2. 标出各个运算符的生效顺序(先后顺序有点出入无所谓);
3. 按顺序加入运算符,注意**分层**;
4. 从底向上逐层检查同层的运算符是否可以合体.

> 以`(a*b)*(a*b)*(a*b)*c`为例
> 
> * **第一步**:把各个操作数不重复地排成一排
> 
> ![](https://cdn.acwing.com/media/article/image/2023/10/22/85276_e1e097d170-20231022154437.png) 
> 
> * **第二步**:标出各个运算符的生效顺序(先后顺序有点出入无所谓)
> 
> ![](https://cdn.acwing.com/media/article/image/2023/10/22/85276_1709280270-20231022154607.png) 
> 
> * **第三步**:按顺序加入运算符,注意**分层**
> 
> ![](https://cdn.acwing.com/media/article/image/2023/10/22/85276_6782a5da70-20231022154821.png) 
> 
> * **第四步**:从底向上逐层检查同层的运算符是否可以合体
> 
> ![](https://cdn.acwing.com/media/article/image/2023/10/22/85276_9da2932a70-20231022154927.png) 
> 
> ![](https://cdn.acwing.com/media/article/image/2023/10/22/85276_a0d42b6070-20231022154946.png) 

#### 拓扑排序

在图论中,拓扑排序是一个**有向无环图**的所有顶点的线性序列,且该序列必须满足以下两个条件:

* 每个顶点出现且出现一次;
* 若存在一条从顶点 $A$到顶点 $B$的路径,那么在序列中顶点 $A$出现在顶点 $B$的前面.

有向无环图( $DAG$)才有拓扑排序,非 $DAG$无拓扑排序.例如下图中存在拓扑排序( $A,B,C,D$或 $A,C,B,D$可说明**拓扑排序不唯一**)

 ![](https://cdn.acwing.com/media/article/image/2023/10/22/85276_4c3521fe70-20231022160853.png) 

又如下图中不存在拓扑排序(存在 $B,C,D$构成的环,可说明拓扑排序可**判断有向图是否有环**)

![](https://cdn.acwing.com/media/article/image/2023/10/22/85276_4fde439470-20231022160903.png) 

拓扑排序的**求法及步骤**

* 该图中选择一个没有前驱(即入度为 $0$的顶点并记录该顶点;
* 从图中删除该顶点和所有以它为起点的有向边;
* 重复上述步骤,直到当前的图为**空**或者**当前图中不存在没有前驱（入度为0）的顶点**为止,如果满足后一种情况说明**有向图必然存在环**.

![](https://cdn.acwing.com/media/article/image/2023/10/22/85276_d4edbed670-20231022161256.png) 

#### 关键路径

在带权有向图,以**顶点表示事件**,以**有向边表示活动**,以**边上的权值表示完成该活动的开销**(如完成活动所需的时间),称之为用边表示活动的网络,简称 $AOE$网(`Activity On Edge NetWork`).在 $AOV$网中的边无权值,仅表示**顶点之间的前后关系**.

在 $AOE$网具有以下两个性质:

* 只有在某顶点所代表的事件发生后,从该顶点出发的各有向边所代表的活动才能开始;
* 只有在进入某顶点的各有向边所代表的活动都已结束时,该顶点所发表的事件才能发生.

在 $AOE$网中**仅有一个**入度为 $0$的顶点,称为**开始顶点(源点)**,它表示整个工程的开始;网中也**仅存在一个**出度为 $0$的顶点,称为**结束顶点(汇点)**,它表示整个工程的结束.

从源点到汇点的有向路径可能有多条,所有路径中,具有最大路径长度的路径称为**关键路径**,而把关键路径上的活动称为**关键活动**.完成整个工程的最短时间就是关键路径的长度，若关键活动不能按时完成，则整个工程的完成时间就会延长.

* **事件** $v_k$的**最早发生时间** $ve(k)$

>  它是指从源点 $v_1$到顶点 $v_k$的最长路径长度.事件 $v_k$的最早发生时间决定了所有从 $v_k$开始的活动能够开工的最早时间.
>
>  * $ve(源点)=0$;
>
>  * $\color{Red}{ve(k)=max(ve(j)+weight(v_j,v_k))}$, $v_k$为 $v_j$的任意后继, $weight(v_j,v_k)$表示 $\left< v_j,v_k \right>$上的权值.
>
>  计算 $ve()$值时,按从前往后的顺序进行,可以在**拓扑排序**的基础上计算:
>
>  * 初始时,令 $ve[1,\cdots,n]=0$;
>  * 输入一个入度为 $0$的顶点 $v_j$时,计算它所有直接后继顶点 $v_k$的最早发生时间,若 $ve[j]+weight(v_j,v_k)>ve[k]$,则 $ve[k]=ve[k]+weight(v_j,v_k)$.以此类推,直至输出全部顶点.

* **事件** $v_k$的**最迟发生时间** $vl(k)$

> 它是指不推迟整个工程完成的前提下,即保证它的后继事件 $v_j$在其最迟发生时间 $vl(j)$能够发生时,该事件最迟必须发生的时间.
>
> *  $vl(汇点)=ve(汇点)$;
> *  $\color{Red}{vl(k)=min(vl(j)-weight(v_k,v_j))}$, $v_k$为 $v_j$的任意前驱.
>
> 计算 $vl()$值时,按从后往前的顺序进行,可以在**逆拓扑排序**(在上述拓扑排序中,增设一个栈以记录拓扑序列,**拓扑排序结束后从栈顶至栈底**为逆拓扑有序序列)的基础上计算.
>
> * 初始时,令 $vl(1,\cdots,n)=ve[n]$;
> * 栈顶顶点 $v_j$出栈,计算其所有直接前驱顶点 $v_k$的最迟发生时间,若 $vl[j]-weight(v_k,v_j) < vl[k]$,则 $vl[k]=vl[j]-weight(v_k,v_j)$.以此类推,直至输出全部栈中顶点.

* **活动** $a_i$的**最早开始时间** $e(i)$

> 它是指该**活动弧的起点**所表示的事件的**最早发生时间**. 若边 $\left< v_k, v_j \right>$表示活动 $a_i$,则有 $\color{Red}{e(i)=ve(k)}$.

* **活动** $a_i$的**最迟开始时间** $l(i)$

>  它是指该**活动弧的终点**所表示的事件的**最迟发生时间与该活动所需时间之差**.若边 $\left< v_k, v_j \right>$表示活动 $a_i$,则有 $\color{Red}{l(i)=vl(j)-weight(v_k,v_j)}$.

* 一个**活动** $a_i$的**最迟开始时间** $l(i)$和其**最早开始时间** $e(i)$的**差额** $\color{Red}{d(i)=l(i)-e(i)}$

>  它是指活动完成的**时间余量**,即在不增加完成整个工程所需总时间的情况下,活动 $a_i$可以拖延的时间.若一个活动的时间余量为零,则说明该活动必须要如期完成,否则就会拖延整个工程的进度,故称 $l(i)-e(i)=0$即 $l(i)=e(i)$的活动 $a_i$是关键活动.

求解**关键路径**的步骤:

1. 从**源点**出发,令 $ve(源点)=0$,按**拓扑**有序求其余顶点(事件)的最早发生时间 $ve()$.
2. 从**汇点**出发,令 $vl(汇点)=ve(汇点)$,按**逆拓扑**有序求其余顶点(事件)的最迟发生时间 $vl()$.
3. 根据各**顶点(事件)**的 $ve()$值求**所有弧(活动)的最早开始时间** $e()$.
4. 根据**各顶点(事件)**的 $vl()$值求**所有弧(活动)的最迟开始时间** $l()$.
5. 求 $AOE$网中所有活动的**差额** $d()$,找出所有 $d()=0$的活动构成关键路径.

>  **举例**：
>
>  ![](https://cdn.acwing.com/media/article/image/2023/10/23/85276_63e9f6ab71-20231023165238.png) 
>
>  拓扑序列为 $\color{Red}{V_1,V_2,V_3,V_4,V_5,V_6}$(其中 $V_2,V_3$可相互交换, $V_4,V_5$可相互交换)
>
>  首先计算事件**最早发生时间** $ve()$(考虑**到达** $V_i$的边)
>
>  *  对于事件 $V_1$,由于 $V_1$是源点,故 $ve(1)=0$;
>
>  * 对于事件 $V_2$,仅存在从 $V_1$到 $\color{Red}{V_2}$的边 $a_1=3$,故 $ve(2)=ve(1)+a_1=3$;
>
>  * 对于事件 $V_3$,仅存在从 $V_1$到 $\color{Red}{V_3}$的边 $a_2=2$,故 $ve(3)=ve(1)+a_2=2$;
>
>  * 对于事件 $V_4$,存在从 $V_2$到 $\color{Red}{V_4}$的边 $a_3=2$和从 $V_3$到 $\color{Red}{V_4}$的边 $a_5=4$, 两者取**最大值**,故 $ve(4)=max(ve(2)+a_3,ve(3)+a_5)=max(5,6)=6$;
>
>  * 对于事件 $V_5$,仅存在从 $V_2$到 $\color{Red}{V_5}$的边 $a_4=3$,故 $ve(5)=ve(2)+a_4=6$;
>
>  * 对于事件 $V_6$,存在从 $V_3$到 $\color{Red}{V_6}$的边 $a_6=3$、从 $V_4$到 $\color{Red}{V_6}$的边 $a_7=2$和从 $V_5$到 $\color{Red}{V_6}$的边 $a_8=1$,三者取**最大值**,故 $ve(6)=max(ve(3)+a_6,ve(4)+a_7,ve(5)+a_8)=max(5,8,7)=8$.
>
>  然后计算事件**最迟发生时间** $vl()$(考虑从 $V_i$**出发**的边)
>
>  * 对于事件 $V_6$,由于 $V_6$是汇点,故 $vl(6)=ve(6)=8$;
>  * 对于事件 $V_5$,仅存在从 $\color{Green}{V_5}$到 $V_6$的边 $a_8=1$,故 $vl(5)=vl(6)-a_8=7$;
>  * 对于事件 $V_4$,仅存在从 $\color{Green}{V_4}$到 $V_6$的边 $a_7=2$,故 $vl(4)=vl(6)-a_7=6$;
>  * 对于事件 $V_3$,存在从 $\color{Green}{V_3}$到 $V_6$的边 $a_6=3$和从 $\color{Green}{V_3}$到 $V_4$的边 $a_5=4$,两者取**最小值**,故 $vl(3)=min(vl(6)-a_6,vl(4)-a_5)=min(5,2)=2$;
>  * 对于事件 $V_2$,存在从 $\color{Green}{V_2}$到 $V_4$的边 $a_3=2$和从 $\color{Green}{V_2}$到 $V_5$的边 $a_4=3$,两者取**最小值**,故 $vl(2)=min(vl(4)-a_3,vl(5)-a_4)=min(4,4)=4$;
>  * 对于事件 $V_1$,存在从 $\color{Green}{V_1}$到 $V_2$的边 $a_1=3$和从 $\color{Green}{V_1}$到 $V_3$的边 $a_2=2$,两者取**最小值**,故 $vl(1)=min(vl(2)-a_1,vl(3)-a_2)=min(1,0)=0$.
>
>  接着计算活动**最早开始时间** $e()$和**最迟开始时间** $l()$(**最早看弧起点,最迟看弧终点**)
>
>  * 对于活动 $a_1$,弧起点为 $V_1$,弧终点为 $V_2$,故 $e(1)=ve(1)=0$, $l(1)=vl(2)-a_1=1$;
>
>  * 对于活动 $a_2$,弧起点为 $V_1$,弧终点为 $V_3$,故 $e(2)=ve(1)=0$, $l(2)=vl(3)-a_2=0$;
>
>  * 对于活动 $a_3$,弧起点为 $V_2$,弧终点为 $V_4$,故 $e(3)=ve(2)=3$, $l(3)=vl(4)-a_3=4$;
>
>  * 对于活动 $a_4$,弧起点为 $V_2$,弧终点为 $V_5$,故 $e(4)=ve(2)=3$, $l(4)=vl(5)-a_4=4$;
>
>  * 对于活动 $a_5$,弧起点为 $V_3$,弧终点为 $V_4$,故 $e(5)=ve(3)=2$, $l(5)=vl(4)-a_5=2$;
>
>  * 对于活动 $a_6$,弧起点为 $V_3$,弧终点为 $V_6$,故 $e(6)=ve(3)=2$, $l(6)=vl(6)-a_6=5$;
>
>  * 对于活动 $a_7$,弧起点为 $V_4$,弧终点为 $V_6$,故 $e(7)=ve(4)=6$, $l(7)=vl(6)-a_7=6$;
>
>  * 对于活动 $a_8$,弧起点为 $V_5$,弧终点为 $V_6$,故 $e(8)=ve(5)=6,l(8)=vl(6)-a_8=7$;
>
>  最后计算 **最迟开始时间** $l()$和其**最早开始时间** $e()$的**差额** $\color{Red}{d()=l()-e()}$(根据 $l()$是否与 $e()$相等)
>
>  * 对于活动 $a_1$, $e(1) \neq l(1)$,故活动 $a_1$不是关键活动;
>  * 对于活动 $a_2$, $e(2) = l(2)$,故活动 $a_2$是**关键活动**;
>  * 对于活动 $a_3$, $e(3) \neq l(3)$,故活动 $a_3$不是关键活动;
>  * 对于活动 $a_4$, $e(4) \neq l(4)$,故活动 $a_4$不是关键活动;
>  * 对于活动 $a_5$, $e(5) = l(5)$,故活动 $a_5$是**关键活动**;
>  * 对于活动 $a_6$, $e(6) \neq l(6)$,故活动 $a_6$不是关键活动;
>  * 对于活动 $a_7$, $e(7) \neq l(7)$,故活动 $a_7$是**关键活动**;
>  * 对于活动 $a_8$, $e(8) \neq l(8)$,故活动 $a_8$不是关键活动;
>
>  综上,故 $a_2,a_5,a_7$为关键活动, $(V_1,V_3,V_4,V_6)$为关键路径.
>
>  ![](https://cdn.acwing.com/media/article/image/2023/10/23/85276_efe8be5371-20231023194710.png) 

关键路径上的所有活动都是关键活动,它是决定整个工程的关键因素,因此可以**通过加快关键活动来缩短整个工程的工期**.但也不能任意缩短关键活动,因为一旦**缩短到一定的程度**,**该关键活动就能变成非关键活动**.

网中关键路径并不唯一,且对于有几条关键网络的网,**只提高一条关键路径上的关键活动速度并不能缩短整个工程的工期**,只有**加快那些包括在所有关键路径上的关键活动**才能达到缩短工期的目的.

>  已知带权连通无向图 $G=(V,E)$,其中 `V={` $v_1,v_2,v_3,v_4,v_5,v_6,v_7$ `}`, `E={` $(v_1,v_2)10,(v_1,v_3)2,(v_3,v_4)2,(v_3,v_6)11,$ $(v_2,v_5)1,(v_4,v_5)4,(v_4,v_6)6,(v_5,v_7)7,(v_6,v_7)3$`}`(注:顶点偶对括号外的数据表示边上的权值),从源点 $v_1$到顶点 $v_7$的最短路径上经过的顶点序列是().
>
> A. $v_1,v_2,v_5,v_7$
>
> B. $\color{Red}{v_1,v_3,v_4,v_6,v_7}$
>
> C. $v_1,v_3,v_4,v_5,v_7$
>
> D. $v_1,v_2,v_5,v_4,v_6,v_7$

![](https://cdn.acwing.com/media/article/image/2023/10/23/85276_276c8ddc71-20231023203851.png) 

* 选项 $A$,对于顶点序列 $v_1,v_2,v_5,v_7$,路径和为 $10+1+7=18$;
* 选项 $B$,对于顶点序列 $v_1,v_3,v_4,v_6,v_7$,路径和为 $2+2+6+3=13$;
* 选项 $C$,对于顶点序列 $v_1,v_3,v_4,v_5,v_7$,路径和为 $2+2+4+7=15$;
* 选项 $D$,对于顶点序列 $v_1,v_2,v_5,v_4,v_6,v_7$,路径和为 $10+1+4+6+3=24$;

故最短路径为 $v_1 \to v_3 \to v_4 \to v_6 \to v_7$.

>  下图所示有向图的所有拓扑序列共有()个.
>
>  ![](https://cdn.acwing.com/media/article/image/2023/10/24/85276_ed0e49b472-20231024143749.png) 
>
>  A. $4$
>
>  B. $6$
>
>  C. $\color{Red}{5}$
>
>  D. $7$

拓扑排序序列可能如下(共 $5$种):

*  $ABCDEFG$
*  $ABCDFEG$
*  $ABCFDEG$
*  $ABDCEFG$
*  $ABDCFEG$

>  下列关于图的说法中,正确的是( $\color{Red}{C}$).
>
>  Ⅰ. 有向图中顶点 $V$的度等于其邻接矩阵中第 $V$行中 $1$的个数
>
>  Ⅱ. 无向图的邻接矩阵一定是对称矩阵,有向图的邻接矩阵一定是非对称矩阵
>
>  Ⅲ. 在带权图 $G$的最小生成树 $G_1$中,某条边的权值可能会超过未选边的权值
>
>  Ⅳ. 若有向无环图的拓扑序列唯一,则可以唯一确定该图
>
>  A. Ⅰ、Ⅱ和Ⅲ
>
>  B. Ⅲ和Ⅳ
>
>  C. Ⅲ
>
>  D. Ⅳ

* 对于Ⅰ,邻接矩阵中第 $V$行中 $1$的个数表示有向图中顶点 $V$的出度,邻接矩阵中第 $V$列中 $1$的个数表示有向图中顶点 $V$的入度,而有向图中顶点的度为入度和出度的和,故Ⅰ错误;
* 对于Ⅱ,无向图可看作特殊的有向图,故有向图不一定是非对称矩阵,故Ⅱ错误;
* 对于Ⅲ,最小生成树中的 $n-1$条边并不能保证是图中权值最小的 $n-1$条边,因为**权值最小的** $n-1$**条边并不一定使得图连通**,故Ⅲ正确;

![](https://cdn.acwing.com/media/article/image/2023/10/24/85276_190de5d372-20231024150055.png) 

* 对于Ⅳ,**有向无环图的拓扑序列唯一并不能唯一确定该图**,故Ⅳ错误.

![](https://cdn.acwing.com/media/article/image/2023/10/24/85276_8152b2e072-20231024150323.png) 

>  若某带权图为 $G=(V,E)$,其中`V={` $v_1,v_2,v_3,v_4,v_5,v_6,v_7,v_8,v_9,v_{10}$ `}`, `E={` $\left< v_1,v_2 \right> 5, \left< v_1,v_3 \right> 6 , \left< v_2,v_5 \right> 3, \left< v_3,v_5 \right> 6, \left< v_3,v_4 \right> 3,$ $\left< v_4,v_5\right>3,\left< v_4,v_7\right>1,\left< v_4,v_8\right>4,\left< v_5,v_6 \right>4, \left< v_5,v_7 \right>2,\left< v_6,v_{10} \right>4,$ $\left< v_7,v_9\right>5,\left< v_8,v_9\right>2,\left< v_9,v_{10}\right>2$ `}`(注:边括号外的数据表示边上的权值),则 $G$的关键路径的长度为().
>
>  A. $19$
>
>  B. $20$
>
>  C. $\color{Red}{21}$
>
>  D. $22$

关键路径为 $(v_1,v_3,v_4(可省略),v_5,v_7,v_9,v_{10})$,关键路径长度为 $6+6(或3+3)+2+5+2=21$.

![](https://cdn.acwing.com/media/article/image/2023/10/24/85276_8b483a0472-20231024153240.png) 

> 下面关于求关键路径的说法中,不正确的是( $\color{Red}{C}$)
>
> A. 求关键路径是以拓扑排序为基础的
>
> B. 一个事件的最早发生时间与该事件为始的弧的活动的最早开始时间相同
>
> C. 一个事件的最迟发生时间是以该事件尾的弧的活动的最迟开始时间与该活动的持续时间的差
>
> D. 关键活动一定位于关键路径上

一个事件的最迟发生时间 $=min$ `{`以该事件为尾(出发)的弧的**活动**的最迟开始时间 `}`或 $min$ `{` 以该事件为尾(出发)的弧所指的**事件**的最迟发生时间与该弧的活动的持续时间之差 `}`.

>  **2010统考真题**：对下图进行拓扑排序,可得不同拓扑序列的个数是().
>
> ![](https://cdn.acwing.com/media/article/image/2023/10/24/85276_2c55f39e72-20231024155132.png) 
>
> A. $4$
>
> B. $\color{Red}{3}$
>
> C. $2$
>
> D. $1$

拓扑排序序列可能如下(共 $3$种):

*  $aebcd$
* $abced$
* $abecd$

>  **2012统考真题**：对下图所示的有向带权图,若采用 $Dijkstra$算法从源点 $a$到其他各顶点的最短路径,则得到的第一条最短路径的目标顶点是 $b$,第二条最短路径的目标顶点是 $c$,后续得到的其余各最短路径的目标顶点依次是().
>
> ![](https://cdn.acwing.com/media/article/image/2023/10/24/85276_e7b126e472-20231024161815.png) 
>
> A. $d,e,f$
>
> B. $e,d,f$
>
> C. $\color{Red}{f,d,e}$
>
> D. $f,e,d$

可通过下表可看出最后选择的目标顶点依次是 $f,d,e$.

![](https://cdn.acwing.com/media/article/image/2023/10/24/85276_72450bc772-20231024162919.png) 

>  **2013统考真题**：下列 $AOE$网表示一项包含 $8$个活动的工程,通过同时加快若干活动的进度可以缩短整个工程的工期.下列选项中,可以加快其进度就可以缩短工程工期的是().
>
> ![](https://cdn.acwing.com/media/article/image/2023/10/24/85276_f1d7f65972-20231024163253.png) 
>
> A. $c和e$
>
> B. $d和c$
>
> C. $\color{Red}{f和d}$
>
> D. $f和h$

拓扑序列为 $1,3,2,4,5,6$(其中 $4,5$可交换)

首先计算事件**最早发生时间** $ve()$(考虑**到达** $V_i$的边)

* 对于事件 $1$,由于 $1$是源点,故 $ve(1)=0$;
* 对于事件 $3$,仅存在从 $1$到 $\color{Red}{3}$的边 $b=8$,故 $ve(3)=ve(0)+b=8$;
* 对于事件 $2$,存在从 $1$到 $\color{Red}{2}$的边 $a=3$和从 $3$到 $\color{Red}{2}$的边 $d=4$, 两者取**最大值**,故 $ve(2)=max(ve(1)+a,ve(3)+d)=max(3,12)=12$;
* 对于事件 $4$,仅存在从 $2$到 $\color{Red}{4}$的边 $c=9$,故 $ve(4)=ve(2)+c=21$;
* 对于事件 $5$,存在从 $2$到 $\color{Red}{5}$的边 $e=6$和从 $3$到 $\color{Red}{5}$的边 $f=10$, 两者取**最大值**,故 $ve(5)=max(ve(2)+e,ve(3)+f)=max(18,18)=18$;
* 对于事件 $6$,存在从 $4$到 $\color{Red}{6}$的边 $g=6$和从 $5$到 $\color{Red}{6}$的边 $h=9$,两者取最大值,故 $ve(6)=max(ve(4)+g,ve(5)+h)=max(27,27)=27$.

然后计算事件**最迟发生时间** $vl()$(考虑从 $V_i$**出发**的边)

* 对于事件 $6$,由于 $6$是汇点,故 $vl(6)=ve(6)=27$;
* 对于事件 $5$,仅存在从 $\color{Green}{5}$到 $6$的边 $h=9$,故 $vl(5)=vl(6)-h=18$;
* 对于事件 $4$,仅存在从 $\color{Green}{4}$到 $6$的边 $g=6$,故 $vl(4)=vl(6)-g=21$;
* 对于事件 $2$,存在从 $\color{Green}{2}$到 $4$的边 $c=9$和从 $\color{Green}{2}$到 $5$的边 $e=6$,两者取**最小值**,故 $vl(2)=min(vl(4)-c,vl(5)-e)=min(12,12)=12$;
* 对于事件 $3$,存在从 $\color{Green}{3}$到 $5$的边 $f=10$和从 $\color{Green}{3}$到 $2$的边 $d=4$,两者取**最小值**,故 $vl(3)=min(vl(5)-f,vl(2)-d)=min(8,8)=8$;
* 对于事件 $1$,存在从 $\color{Green}{1}$到 $2$的边 $a=3$和从 $\color{Green}{1}$到 $3$的边 $b=8$,两者取**最小值**,故 $vl(1)=min(vl(2)-a,vl(3)-b)=min(9,0)=0$.

计算事件的最早发生时间和最迟发生时间如下表:

![](https://cdn.acwing.com/media/article/image/2023/10/24/85276_f13e229a72-20231024171547.png) 

接着计算活动**最早开始时间** $e()$和**最迟开始时间** $l()$(**最早看弧起点,最迟看弧终点**)

* 对于活动 $a$,弧起点为 $1$,弧终点为 $2$,故 $e(a)=ve(1)=0$, $l(a)=vl(2)-a=9$;
* 对于活动 $b$,弧起点为 $1$,弧终点为 $3$,故 $e(b)=ve(1)=0$, $l(b)=vl(3)-b=0$;
* 对于活动 $c$,弧起点为 $2$,弧终点为 $4$,故 $e(c)=ve(2)=12$, $l(c)=vl(4)-c=12$;
* 对于活动 $d$,弧起点为 $3$,弧终点为 $2$,故 $e(d)=ve(3)=8$, $l(d)=vl(2)-d=8$;
* 对于活动 $e$,弧起点为 $2$,弧终点为 $5$,故 $e(e)=ve(2)=12$, $l(e)=vl(5)-e=12$;
* 对于活动 $f$,弧起点为 $3$,弧终点为 $5$,故 $e(f)=ve(3)=8$, $l(f)=vl(5)-f=8$;
* 对于活动 $g$,弧起点为 $4$,弧终点为 $6$,故 $e(g)=ve(4)=21$, $l(g)=vl(6)-g=21$;
* 对于活动 $h$,弧起点为 $5$,弧终点为 $6$,故 $e(h)=ve(5)=18$, $l(h)=vl(6)-h=18$;

计算活动的最早开始时间和最迟开始时间如下表:

![](https://cdn.acwing.com/media/article/image/2023/10/24/85276_b0e0298572-20231024172819.png) 

故可得出全部关键活动为 $b,d,c,g$和 $b,d,e,h$和 $b,f,h$.只有关键路径上的活动时间同时减少时,才能缩短工期.而当 $f$和 $d$同时减少会缩短工期.

>   **2012统考真题**：若用邻接矩阵存储有向图,矩阵中主对角线以下的元素均为零,则关于该图拓扑序列的结论是( $\color{Red}{C}$).
>
> A. 存在,且唯一
>
> B. 存在,且不唯一
>
> C. 存在,可能不唯一
>
> D. 无法确定是否存在

对角线以下的元素均为零,表明只有从顶点 $i$到顶点 $j$( $i < j$)可能有边,而从顶点 $j$到顶点 $i$一定无边,即有向图是一个无环图,故一定存在拓扑序列.

对于下图对应的拓扑序列为 $1,2,3$或 $1,3,2$,故此时**存在不唯一**的拓扑序列;若对角线以上的元素均为 $1$,以下元素全为 $0$,则拓扑序列**唯一**.

![](https://cdn.acwing.com/media/article/image/2023/10/24/85276_ac1f0ed672-20231024175645.png) 

>  **2014统考真题**：对下图所示的有向图进行拓扑排序,得到的拓扑序列可能是().
>
> ![](https://cdn.acwing.com/media/article/image/2023/10/24/85276_0be9c41572-20231024175929.png) 
>
> A. $3,1,2,4,5,6$
>
> B. $3,1,2,4,6,5$
>
> C. $3,1,4,2,5,6$
>
> D. $\color{Red}{3,1,4,2,6,5}$

该图的拓扑序列为 $3,1,4,2,6,5$( $2,6$可**交换顺序**)

>   **2015统考真题**：求下面的带权图的最小(代价)生成树时,可能是 $Kruskal$算法第 $2$次选中但不是 $Prim$算法(从 $V_4$开始)第 $2$次选中的边是().
>
> ![](https://cdn.acwing.com/media/article/image/2023/10/24/85276_ab462beb72-20231024180358.png) 
>
> A. $(V_1,V_3)$
>
> B. $(V_1,V_4)$
>
> C. $\color{Red}{(V_2,V_3)}$
>
> D. $(V_3,V_4)$

对于 $Kruskal$算法第一步会选择 $(V_1,V_4)$,第二歩会选择 $(V_1,V_3)$或 $\color{Red}{(V_2,V_3)}$或者 $(V_3,V_4)$;而对于 $Prim$算法第一步会选择 $(V_1,V_4)$,第二歩会选择 $(V_1,V_3)$或者$(V_3,V_4)$.

>  **2016统考真题**：使用 $Dijkstra$算法求下图中从顶点 $1$到其他各顶点的最短路径,依次得到的各最短路径的目标顶点是().
>
> ![](https://cdn.acwing.com/media/article/image/2023/10/24/85276_18f2119772-20231024193254.png) 
>
> A. $5,2,3,4,6$
>
> B. $\color{Red}{5,2,3,6,4}$
>
> C. $5,2,4,3,6$
>
> D. $5,2,6,3,4$

可通过下表可看出目标顶点(除去起点)依次是 $5,2,3,6,4$

![](https://cdn.acwing.com/media/article/image/2023/10/24/85276_a73f563772-20231024194405.png) 

> **2018统考真题**：下列选项中,不是如下有向图的拓扑序列的是().
>
> ![](https://cdn.acwing.com/media/article/image/2023/10/24/85276_f471808a72-20231024202847.png) 
>
> A. $1,5,2,3,6,4$
>
> B. $5,1,2,6,3,4$
>
> C. $5,1,2,3,6,4$
>
> D. $\color{Red}{5,2,1,6,3,4}$

存在的拓扑序列如下(共 $4$种)

*  $1,5,2,3,6,4$
*  $1,5,2,6,3,4$
*  $5,1,2,3,6,4$
*  $5,1,2,6,3,4$

拓扑排序每次选取入度为 $0$的结点输出,不难发现拓扑序列前两位一定是 $1,5$或 $5,1$(因为只有 $1$和 $5$的入度均为 $0$,且其他结点都不满足仅有 $1$或仅有 $5$作为前驱),故 $D$错误.

>  **2019统考真题**：下图所示的 $AOE$网表示一项包含 $8$个活动的工程,活动 $d$的最早开始时间和最迟开始时间分别是()
>
> ![](https://cdn.acwing.com/media/article/image/2023/10/25/85276_2f4bb4c573-20231025150627.png) 
>
> A. $3和7$
>
> B. $12和12$
>
> C. $\color{Red}{12和14}$
>
> D. $15和15$

拓扑序列为 $1,3,2,4,5,6$(其中 $4,5$可交换)——该图和前面2013统考真题差别在于 $2$到 $4$的边权有变化,且 $b,c,d$编号有出入

首先计算事件**最早发生时间** $ve()$(考虑**到达** $V_i$的边)

* 对于事件 $1$,由于 $1$是源点,故 $ve(1)=0$;
* 对于事件 $3$,仅存在从 $1$到 $\color{Red}{3}$的边 $c=8$,故 $ve(3)=ve(0)+c=8$;
* 对于事件 $2$,存在从 $1$到 $\color{Red}{2}$的边 $a=3$和从 $3$到 $\color{Red}{2}$的边 $b=4$, 两者取**最大值**,故 $ve(2)=max(ve(1)+a,ve(3)+b)=max(3,12)=12$;
* 对于事件 $4$,仅存在从 $2$到 $\color{Red}{4}$的边 $d=7$,故 $ve(4)=ve(2)+d=19$;
* 对于事件 $5$,存在从 $2$到 $\color{Red}{5}$的边 $e=6$和从 $3$到 $\color{Red}{5}$的边 $f=10$, 两者取**最大值**,故 $ve(5)=max(ve(2)+e,ve(3)+f)=max(18,18)=18$;
* 对于事件 $6$,存在从 $4$到 $\color{Red}{6}$的边 $g=6$和从 $5$到 $\color{Red}{6}$的边 $h=9$,两者取最大值,故 $ve(6)=max(ve(4)+g,ve(5)+h)=max(27,27)=27$.

然后计算事件**最迟发生时间** $vl()$(考虑从 $V_i$**出发**的边)

* 对于事件 $6$,由于 $6$是汇点,故 $vl(6)=ve(6)=27$;
* 对于事件 $5$,仅存在从 $\color{Green}{5}$到 $6$的边 $h=9$,故 $vl(5)=vl(6)-h=18$;
* 对于事件 $4$,仅存在从 $\color{Green}{4}$到 $6$的边 $g=6$,故 $vl(4)=vl(6)-g=21$;
* 对于事件 $2$,存在从 $\color{Green}{2}$到 $4$的边 $d=7$和从 $\color{Green}{2}$到 $5$的边 $e=6$,两者取**最小值**,故 $vl(2)=min(vl(4)-d,vl(5)-e)=min(14,12)=12$;
* 对于事件 $3$,存在从 $\color{Green}{3}$到 $5$的边 $f=10$和从 $\color{Green}{3}$到 $2$的边 $b=4$,两者取**最小值**,故 $vl(3)=min(vl(5)-f,vl(2)-b)=min(8,8)=8$;
* 对于事件 $1$,存在从 $\color{Green}{1}$到 $2$的边 $a=3$和从 $\color{Green}{1}$到 $3$的边 $c=8$,两者取**最小值**,故 $vl(1)=min(vl(2)-a,vl(3)-c)=min(9,0)=0$.

计算事件的最早发生时间和最迟发生时间如下表:

![](https://cdn.acwing.com/media/article/image/2023/10/25/85276_460310cc73-20231025152229.png) 

接着计算活动**最早开始时间** $e()$和**最迟开始时间** $l()$(**最早看弧起点,最迟看弧终点**)

* 对于活动 $a$,弧起点为 $1$,弧终点为 $2$,故 $e(a)=ve(1)=0$, $l(a)=vl(2)-a=9$;
* 对于活动 $b$,弧起点为 $3$,弧终点为 $2$,故 $e(b)=ve(3)=8$, $l(b)=vl(2)-b=8$;
* 对于活动 $c$,弧起点为 $1$,弧终点为 $3$,故 $e(c)=ve(1)=0$, $l(c)=vl(3)-c=0$;
* 对于活动 $d$,弧起点为 $2$,弧终点为 $4$,故 $e(d)=ve(2)=12$, $l(d)=vl(4)-d=14$;
* 对于活动 $e$,弧起点为 $2$,弧终点为 $5$,故 $e(e)=ve(2)=12$, $l(e)=vl(5)-e=12$;
* 对于活动 $f$,弧起点为 $3$,弧终点为 $5$,故 $e(f)=ve(3)=8$, $l(f)=vl(5)-f=8$;
* 对于活动 $g$,弧起点为 $4$,弧终点为 $6$,故 $e(g)=ve(4)=19$, $l(g)=vl(6)-g=21$;
* 对于活动 $h$,弧起点为 $5$,弧终点为 $6$,故 $e(h)=ve(5)=18$, $l(h)=vl(6)-h=18$;

计算活动的最早开始时间和最迟开始时间如下表:

![](https://cdn.acwing.com/media/article/image/2023/10/25/85276_8332bcc273-20231025153122.png) 

故由表知,活动 $d$的最早开始时间和最迟开始时间分别为 $12,14$.

>  **2019统考真题**：用有向无环图描述表达式 $(x+y)((x+y)/x)$,需要的顶点个数至少是().
>
> A. $\color{Red}{5}$
>
> B. $6$
>
> C. $8$
>
> D. $9$

首先将该表达式转换成有向二叉树,然后将有向二叉树去重转换成有向无环图,故化简后至少需要 $5$个顶点.

 ![](https://cdn.acwing.com/media/article/image/2023/10/25/85276_6a52fd4673-20231025153641.png) 

>  **2020统考真题**：已知无向图 $G$如下所示,使用克鲁斯卡尔( $Kruskal$)算法求图 $G$的最小生成树,加到最小生成树的边依次是().
>
> ![](https://cdn.acwing.com/media/article/image/2023/10/25/85276_299c154173-20231025154302.png) 
>
> A. $\color{Red}{(b,f),(b,d),(a,e),(c,e),(b,e)}$
>
> B. $(b,f),(b,d),(b,e),(a,e),(c,e)$
>
> C. $(a,e),(b,e),(c,e),(b,d),(b,f)$
>
> D. $(a,e),(c,e),(b,e),(b,f),(b,d)$

由该图知,加到最小生成树的边依次 $(b,f),(b,d),(a,e),(c,e),(b,e)$.

![](https://cdn.acwing.com/media/article/image/2023/10/25/85276_1c37261473-20231025154954.png) 

>  **2021统考真题**：给定如下有向图,该图的拓扑有序序列的个数是().
>
> ![](https://cdn.acwing.com/media/article/image/2023/10/25/85276_cae2854f73-20231025155452.png) 
>
> A. $\color{Red}{1}$
>
> B. $2$
>
> C. $3$
>
> D. $4$

该图的拓扑有序序列仅为 $A,B,C,D,E,F$,故只有 $1$个.

>  **2021统考真题**：使用 $Dijkstra$算法求下图中从顶点 $1$到其余各顶点的最短路径,将当前找到的从顶点 $1$到顶点 $2,3,4,5$的最短路径长度保存在数组 $dist$中,求出第二条最短路径后, $dist$中的内容更新为().
>
> ![](https://cdn.acwing.com/media/article/image/2023/10/25/85276_7e95111c73-20231025160655.png) 
>
> A. $26,3,14,6$
>
> B. $25,3,14,6$
>
> C. $\color{Red}{21,3,14,6}$
>
> D. $15,3,14,6$

由表知求出第二条最短路径后, $dist$中的内容更新为 $21,3,14,6$

![](https://cdn.acwing.com/media/article/image/2023/10/25/85276_c5aecd1d73-20231025163736.png)

![](https://cdn.acwing.com/media/article/image/2023/10/25/85276_9dea689f73-20231025163630.png) 

>  **2022统考真题**：下图是一个有 $10$个活动的 $AOE$网,时间余量最大的活动是().
>
> ![](https://cdn.acwing.com/media/article/image/2023/10/25/85276_692d8b0e73-20231025164200.png) 
>
> A. $c$
>
> B. $\color{Red}{g}$
>
> C. $h$
>
> D. $j$

拓扑序列为 $1,2,3,4,5,6$

首先计算事件**最早发生时间** $ve()$(考虑**到达** $V_i$的边)

* 对于事件 $1$,由于 $1$是源点,故 $ve(1)=0$;
* 对于事件 $2$,仅存在从 $1$到 $\color{Red}{2}$的边 $a=2$,故 $ve(2)=ve(1)+a=2$;
* 对于事件 $3$,存在从 $1$到 $\color{Red}{3}$的边 $b=5$和从 $2$到 $\color{Red}{3}$的边 $c=1$, 两者取**最大值**,故 $ve(3)=max(ve(1)+b,ve(2)+c)=max(5,3)=5$;
* 对于事件 $4$,存在从 $2$到 $\color{Red}{4}$的边 $d=3$和从 $3$到 $\color{Red}{4}$的边 $e=3$, 两者取**最大值**,故 $ve(4)=max(ve(2)+d,ve(3)+e)=max(5,8)=8$;
* 对于事件 $5$,存在从 $3$到 $\color{Red}{5}$的边 $f=4$和从 $4$到 $\color{Red}{5}$的边 $h=1$, 两者取**最大值**,故 $ve(5)=max(ve(3)+f,ve(4)+h)=max(9,9)=9$;
* 对于事件 $6$,存在从 $3$到 $\color{Red}{6}$的边 $g=1$、从 $4$到 $\color{Red}{6}$的边 $i=4$和从 $5$到 $\color{Red}{6}$的边 $j=1$, 三者取**最大值**,故 $ve(3)=max(ve(3)+g,ve(4)+i,ve(5)+j)=max(6,12,10)=12$;

然后计算事件**最迟发生时间** $vl()$(考虑从 $V_i$**出发**的边)

* 对于事件 $6$,由于 $6$是汇点,故 $vl(6)=ve(6)=12$;
* 对于事件 $5$,仅存在从 $\color{Green}{5}$到 $6$的边 $j=1$,故 $vl(5)=vl(6)-j=11$;
* 对于事件 $4$,存在从 $\color{Green}{4}$到 $5$的边 $h=1$和从 $\color{Green}{4}$到 $6$的边 $i=4$,两者取**最小值**,故 $vl(4)=min(vl(5)-h,vl(6)-i)=min(10,8)=8$;
* 对于事件 $3$,存在从 $\color{Green}{3}$到 $4$的边 $e=3$、从 $\color{Green}{3}$到 $5$的边 $f=4$和从 $\color{Green}{3}$到 $6$的边 $g=1$,三者取**最小值**,故 $vl(3)=min(vl(4)-e,vl(5)-f,vl(6)-g)=min(5,8,11)=5$;
* 对于事件 $2$,存在从 $\color{Green}{2}$到 $4$的边 $d=3$和从 $\color{Green}{2}$到 $3$的边 $c=1$,两者取**最小值**,故 $vl(2)=min(vl(4)-d,vl(3)-c)=min(5,4)=4$;
* 对于事件 $1$,存在从 $\color{Green}{1}$到 $2$的边 $a=2$和从 $\color{Green}{1}$到 $3$的边 $b=5$,两者取**最小值**,故 $vl(1)=min(vl(2)-a,vl(3)-b)=min(2,0)=0$;

计算事件的最早发生时间和最迟发生时间如下表:

![](https://cdn.acwing.com/media/article/image/2023/10/25/85276_2dee147573-20231025170909.png) 

接着计算活动**最早开始时间** $e()$和**最迟开始时间** $l()$(**最早看弧起点,最迟看弧终点**)

* 对于活动 $a$,弧起点为 $1$,弧终点为 $2$,故 $e(a)=ve(1)=0$, $l(a)=vl(2)-a=2$;
* 对于活动 $b$,弧起点为 $1$,弧终点为 $3$,故 $e(b)=ve(1)=0$, $l(b)=vl(3)-b=0$;
* 对于活动 $c$,弧起点为 $2$,弧终点为 $3$,故 $e(c)=ve(2)=2$, $l(c)=vl(3)-c=4$;
* 对于活动 $d$,弧起点为 $2$,弧终点为 $4$,故 $e(d)=ve(2)=2$, $l(d)=vl(4)-d=5$;
* 对于活动 $e$,弧起点为 $3$,弧终点为 $4$,故 $e(e)=ve(3)=5$, $l(e)=vl(4)-e=5$;
* 对于活动 $f$,弧起点为 $3$,弧终点为 $5$,故 $e(f)=ve(3)=5$, $l(f)=vl(5)-f=7$;
* 对于活动 $g$,弧起点为 $3$,弧终点为 $6$,故 $e(g)=ve(3)=5$, $l(g)=vl(6)-g=11$;
* 对于活动 $h$,弧起点为 $4$,弧终点为 $5$,故 $e(h)=ve(4)=8$, $l(h)=vl(5)-h=10$;
* 对于活动 $i$,弧起点为 $4$,弧终点为 $6$,故 $e(i)=ve(4)=8$, $l(i)=vl(6)-i=8$;
* 对于活动 $j$,弧起点为 $5$,弧终点为 $6$,故 $e(j)=ve(5)=9$, $l(j)=vl(6)-j=11$;

计算活动的最早开始时间、最迟开始时间和时间余量(**两者作差**)如下表(关键路径为 $1,3,4,6$):

![](https://cdn.acwing.com/media/article/image/2023/10/25/85276_69541ad473-20231025171724.png) 

#### 6.4.1

>  下面是一种称为`破圈法`的求解最小生成树的方法:
>
> 所谓`破圈法`,是指`任取一圈,去掉圈上权最大的边`,反复执行这一步骤,直到没有圈为止.
>
> 试判断这种方法是否正确,若正确,说明理由;若不正确,举出反例(注:圈就是回路).
