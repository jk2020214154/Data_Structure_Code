#### 最小生成树

对于一个带权连通无向图 $G=(V,E)$,生成树不同,每棵树的权(即树中所有边上的权值之和)也可能不同,设 $\Re$为 $G$的所有生成树的集合,若 $T$为 $\Re$中边的权值之和最小的那棵生成树，则 $T$称为 $G$的最小生成树( $MST$).

![](https://cdn.acwing.com/media/article/image/2023/10/21/85276_8ca3aaff6f-20200506151404489.png) 

最小生成树的性质：

* 最小生成树不是唯一的,即**最小生成树的树形不唯一**, $\Re$中可能有多个最小生成树.当图 $G$中各边权值互不相同时, $G$的最小生成树是唯一的;若无向连通图 $G$的边数比顶点数少 $1$,即 $G$本身是一棵树时,则 $G$的最小生成树就是它本身.
* 最小生成树的边的权值之和总是唯一的,虽然最小生成树不唯一,但其对应的边的**权值之和总是唯一的且是最小**的.
* 最小生成树的边数为顶点数减 $1$.

##### Prim算法

该算法的时间复杂度为 $O(\left| V \right|^2)$,不依赖于 $\left| E \right|$,它可通过使用**优先队列**把时间复杂度优化为 $O(\left| E\right| \log_{2}{\left| V \right|})$,它适用于求解**边稠密**的图.

该算法可以称为**加点法**,每次迭代选择代价最小的边对应的点,将满足条件的加入到最小生成树中.算法从某个顶点 $s$出发,逐渐覆盖整个连通网的所有顶点.

1. 图的所有顶点集合为 $V$,初始令顶点的集合 `u={s}`,剩余的顶点集合 $v=V-u$;
2. 在两个集合 $u,v$能够组成的边中,选择一条代价最小的边 $e=(u_0,v_0)$,并把这条边加入到最小生成树中,把 $v_0$加入到集合 $u$中;
3. 重复上述步骤,直到最小生成树有 $n-1$条边或者有 $n$个顶点为止.

![](https://cdn.acwing.com/media/article/image/2023/10/21/85276_093e28c86f-20231021174112.png) 

##### Kruskal算法

该算法的时间复杂度为 $O(\left| E \right| \log_{2} \left| E \right|)$,适用于**边稀疏而顶点较多**的图.

该算法可以称为 **加边法** ,初始化最小生成树边数为 $0$,每迭代一次选择一条满足条件的最小代价边,加入到最小生成树的边集合中.

1. 把图中的所有边按代价从小到大排序;
2. 把图中的 $n$个顶点看成独立的 $n$棵树组成的森林;
3. 按权值从小到大选择边,所选的边连接的两个顶点 $u_i,v_i$属于两棵不同的树,使之成为最小生成树的一条边,并将这两棵树合并作为一棵树(**此处用到并查集**);
4. 重复 $(3)$,直到所有顶点都在同一棵树上或者有 $n-1$条边为止.

![](https://cdn.acwing.com/media/article/image/2023/10/21/85276_6f21cfde6f-20231021172957.png) 

#### 最短路径

从图中**某个顶点**出发到达**另外一个顶点的所经过的边的权重和最小的一条路径**，称为最短路径.

单源最短路径问题(`Single Source Shortest Path`, $SSSP$问题),给定一张有向图 $G=(V,E)$, $V$是点集, $E$是边集, $\left| V \right|=n$, $\left| E\right|=m$,结点以 $[1,n]$之间的连续整数编号, $(x,y,z)$描述一条从 $x$出发,到达 $y$,长度为 $z$的有向边.设 $1$号点为起点,求长度为 $n$的数组 $dist$,其中 $dist[i]$表示从 $1$到结点 $i$的最短路径的长度.

##### Dijkstra算法

 $Dijkstra$算法步骤如下：

1. 初始化起点 $start$的 $dist[start]=0$,其余结点的 $dist$的值为**正无穷大**( $+ \infty$);
2. 找出一个**未被标记**的且 $dist[x]$**最小的结点** $x$,然后标记结点 $x$.
3. 扫描结点 $x$的所有出边 $(x,y,z)$,若 $dist[y]>dist[x]+z$,则使用 $dist[x]+z$更新 $dist[y]$.
4. 重复上述 $2 \sim 3$两个步骤,直到所有结点都被标记.

 $Dijkstra$算法基于贪心的思想,它只适用于**所有边的长度都是非负数**的图.当边长 $z$都是非负数时,全局最小值不可能再被其他结点更新,故在第一步选出的结点 $x$必然满足: $dist[x]$已经是起点到 $x$的最短路径.我们不断选择全局最小值进行标记和扩展,最终可得到起点 $start$到每一个结点的最短路径的长度.

>  **举例**：
>
>  1. 用一个 $dis$数组保存源点到其余各个结点的距离, $dis[i]$表示源点到结点 $i$的距离,初始时 $dis$数组的各个元素为无穷大( $+ \infty$);用一个数组 $flag$标记是否找到了源点到该结点的最短距离,初始时 $flag$数组的各个元素清为 $0$;
>
>  ![](https://cdn.acwing.com/media/article/image/2023/10/21/85276_458f871770-20231021211749.png) 
>
>  2. 假设源点是 $1$,将其 $dis[1]$设置为 $0$(源点到源点距离为 $0$);
>
>  ![](https://cdn.acwing.com/media/article/image/2023/10/21/85276_9671d87670-20231021212008.png) 
>
>  3. 遍历 $dis$数组,找到一个结点,这个结点是：**没有确定最短路径的结点中距离源点最近的点**.假设该结点编号为 $i$,此时就找到了源点到该结点的最短距离, $flag[i]$设置为 $1$.
>
>  ![](https://cdn.acwing.com/media/article/image/2023/10/21/85276_104ee59f70-20231021213010.png)
>
>  4. 遍历 $i$所有可以到达的结点 $j$,如果 $dis[j]>dis[i]+w[i][j]$( $w[i][j]$表示 $i \to j$的距离),则更新 $dis[j]$为 $dis[i]+w[i][j]$.
>
>     ![](https://cdn.acwing.com/media/article/image/2023/10/21/85276_7b05aa6b70-20231021213341.png)
>
>  5. 重复 $3 \sim 4$步骤,直到所有结点的 $flag$都标记为 $1$
>
>  ![](https://cdn.acwing.com/media/article/image/2023/10/21/85276_c0bef21f70-20231021213511.png) 
>
>  ![](https://cdn.acwing.com/media/article/image/2023/10/21/85276_c51d93f470-20231021213522.png) 
>
>  ![](https://cdn.acwing.com/media/article/image/2023/10/21/85276_c723e7fa70-20231021213532.png) 
>
>  6. 此时 $dis$数组中,就保存了源点到其余各个结点的最短距离.
>
>  ![](https://cdn.acwing.com/media/article/image/2023/10/21/85276_ee2c960d70-20231021213656.png) 



##### Floyd算法



