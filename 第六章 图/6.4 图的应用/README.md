#### 最小生成树

对于一个带权连通无向图 $G=(V,E)$,生成树不同,每棵树的权(即树中所有边上的权值之和)也可能不同,设 $\Re$为 $G$的所有生成树的集合,若 $T$为 $\Re$中边的权值之和最小的那棵生成树，则 $T$称为 $G$的最小生成树( $MST$).

![](https://cdn.acwing.com/media/article/image/2023/10/21/85276_8ca3aaff6f-20200506151404489.png) 

最小生成树的性质：

* 最小生成树不是唯一的,即**最小生成树的树形不唯一**, $\Re$中可能有多个最小生成树.当图 $G$中各边权值互不相同时, $G$的最小生成树是唯一的;若无向连通图 $G$的边数比顶点数少 $1$,即 $G$本身是一棵树时,则 $G$的最小生成树就是它本身.
* 最小生成树的边的权值之和总是唯一的,虽然最小生成树不唯一,但其对应的边的**权值之和总是唯一的且是最小**的.
* 最小生成树的边数为顶点数减 $1$.

##### Prim算法

该算法的时间复杂度为 $O(\left| V \right|^2)$,不依赖于 $\left| E \right|$,它可通过使用**优先队列**把时间复杂度优化为 $O(\left| E\right| \log_{2}{\left| V \right|})$,它适用于求解**边稠密**的图.

该算法可以称为**加点法**,每次迭代选择代价最小的边对应的点,将满足条件的加入到最小生成树中.算法从某个顶点 $s$出发,逐渐覆盖整个连通网的所有顶点.

1. 图的所有顶点集合为 $V$,初始令顶点的集合 `u={s}`,剩余的顶点集合 $v=V-u$;
2. 在两个集合 $u,v$能够组成的边中,选择一条代价最小的边 $e=(u_0,v_0)$,并把这条边加入到最小生成树中,把 $v_0$加入到集合 $u$中;
3. 重复上述步骤,直到最小生成树有 $n-1$条边或者有 $n$个顶点为止.

![](https://cdn.acwing.com/media/article/image/2023/10/21/85276_093e28c86f-20231021174112.png) 

##### Kruskal算法

该算法的时间复杂度为 $O(\left| E \right| \log_{2} \left| E \right|)$,适用于**边稀疏而顶点较多**的图.

该算法可以称为 **加边法** ,初始化最小生成树边数为 $0$,每迭代一次选择一条满足条件的最小代价边,加入到最小生成树的边集合中.

1. 把图中的所有边按代价从小到大排序;
2. 把图中的 $n$个顶点看成独立的 $n$棵树组成的森林;
3. 按权值从小到大选择边,所选的边连接的两个顶点 $u_i,v_i$属于两棵不同的树,使之成为最小生成树的一条边,并将这两棵树合并作为一棵树(**此处用到并查集**);
4. 重复 $(3)$,直到所有顶点都在同一棵树上或者有 $n-1$条边为止.

![](https://cdn.acwing.com/media/article/image/2023/10/21/85276_6f21cfde6f-20231021172957.png) 

#### 最短路径

从图中**某个顶点**出发到达**另外一个顶点的所经过的边的权重和最小的一条路径**，称为最短路径.

单源最短路径问题(`Single Source Shortest Path`, $SSSP$问题),给定一张有向图 $G=(V,E)$, $V$是点集, $E$是边集, $\left| V \right|=n$, $\left| E\right|=m$,结点以 $[1,n]$之间的连续整数编号, $(x,y,z)$描述一条从 $x$出发,到达 $y$,长度为 $z$的有向边.设 $1$号点为起点,求长度为 $n$的数组 $dist$,其中 $dist[i]$表示从 $1$到结点 $i$的最短路径的长度.

##### Dijkstra算法

 $Dijkstra$算法步骤如下：

1. 初始化起点 $start$的 $dist[start]=0$,其余结点的 $dist$的值为**正无穷大**( $+ \infty$);
2. 找出一个**未被标记**的且 $dist[x]$**最小的结点** $x$,然后标记结点 $x$;
3. 扫描结点 $x$的所有出边 $(x,y,z)$,若 $dist[y]>dist[x]+z$,则使用 $dist[x]+z$更新 $dist[y]$;
4. 重复上述 $2 \sim 3$两个步骤,直到所有结点都被标记.

 $Dijkstra$算法基于贪心的思想,它只适用于**所有边的长度都是非负数**的图.当边长 $z$都是非负数时,全局最小值不可能再被其他结点更新,故在第一步选出的结点 $x$必然满足: $dist[x]$已经是起点到 $x$的最短路径.我们不断选择全局最小值进行标记和扩展,最终可得到起点 $start$到每一个结点的最短路径的长度.

**举例**：

1. 用一个 $dis$数组保存源点到其余各个结点的距离, $dis[i]$表示源点到结点 $i$的距离,初始时 $dis$数组的各个元素为无穷大( $+ \infty$);用一个数组 $flag$标记是否找到了源点到该结点的最短距离,初始时 $flag$数组的各个元素清为 $0$;

![](https://cdn.acwing.com/media/article/image/2023/10/21/85276_458f871770-20231021211749.png) 

2. 假设源点是 $1$,将其 $dis[1]$设置为 $0$(源点到源点距离为 $0$);

![](https://cdn.acwing.com/media/article/image/2023/10/21/85276_9671d87670-20231021212008.png) 

3. 遍历 $dis$数组,找到一个结点,这个结点是：**没有确定最短路径的结点中距离源点最近的点**.假设该结点编号为 $i$,此时就找到了源点到该结点的最短距离, $flag[i]$设置为 $1$;

![](https://cdn.acwing.com/media/article/image/2023/10/21/85276_104ee59f70-20231021213010.png)

4. 遍历 $i$所有可以到达的结点 $j$,如果 $dis[j]>dis[i]+w[i][j]$( $w[i][j]$表示 $i \to j$的距离),则更新 $dis[j]$为 $dis[i]+w[i][j]$;

![](https://cdn.acwing.com/media/article/image/2023/10/21/85276_7b05aa6b70-20231021213341.png)

5. 重复 $3 \sim 4$步骤,直到所有结点的 $flag$都标记为 $1$.

![](https://cdn.acwing.com/media/article/image/2023/10/21/85276_c0bef21f70-20231021213511.png) 

![](https://cdn.acwing.com/media/article/image/2023/10/21/85276_c51d93f470-20231021213522.png) 

![](https://cdn.acwing.com/media/article/image/2023/10/21/85276_c723e7fa70-20231021213532.png) 

6. 此时 $dis$数组中,就保存了源点到其余各个结点的最短距离.

![](https://cdn.acwing.com/media/article/image/2023/10/21/85276_ee2c960d70-20231021213656.png) 

##### Floyd算法

为了求出图中任意两点间的最短路径,当然可以把每个点作为起点,求解 $N$次单源最短路径问题.不过,在任意两点间最短路问题中,图一般比较稠密.使用 $Floyd$算法可以在 $O(n^3)$的时间内完成求解.

1. 初始化邻接矩阵(二维数组) $dist[][]$,其中 $dist[i][j]$表示顶点 $i$到顶点 $j$的权值,若顶点 $i$和顶点 $j$不相邻,则 $dist[i][j]=+ \infty$,若顶点 $i$等于顶点 $j$,则 $dist[i][j]=0$;
2. 以第 $1$个顶点为中介点,若 $dist[i][j]>dist[i][1]+dist[1][j]$,更新 $dist[i][j]$;
3. 依次以第 $2,3,\cdots,k,\cdots,n$个顶点为中介点,若 $dist[i][j]>dist[i][k]+dist[k][j]$,更新 $dist[i][j]$.

**举例**：

![](https://cdn.acwing.com/media/article/image/2023/10/22/85276_4b4b7e2270-20231022150312.png) 

![](https://cdn.acwing.com/media/article/image/2023/10/22/85276_5c08171770-20231022150323.png) 

![](https://cdn.acwing.com/media/article/image/2023/10/22/85276_4f93ef5170-20231022150331.png) 

![](https://cdn.acwing.com/media/article/image/2023/10/22/85276_53c2b1b270-20231022150339.png) 


![](https://cdn.acwing.com/media/article/image/2023/10/22/85276_62a4fae970-20231022150349.png) 

![](https://cdn.acwing.com/media/article/image/2023/10/22/85276_65c801b270-20231022150402.png) 

设 $dist[k,i,j]$表示`经过若干个编号不超过k的结点`,从 $i$到 $j$的最短路长度.该问题可划分为两个子问题,经过编号不超过 $k-1$的结点从 $i$到 $j$,或者从 $i$到 $k$,再到 $j$,可得:

$\color{Red}{dist[k,i,j]=min(dist[k-1,i,j],dist[k-1,i,k]+dist[k-1,k,j])}$

初值为 $dist[0,i,j]=A[i,j]$,其中 $A$为该图的邻接矩阵.

可以看到, $Floyd$算法的本质是**动态规划**, $k$是阶段,应置于最外层循环中, $i$和 $j$是附加状态,应置于内层循环.故不应该采用 $i,j,k$的顺序执行循环,会得到错误的答案. $k$这一维可省略(三维变成二维),最初,可直接用 $dist$保存邻接矩阵,然后执行动态规划的过程.当最外层循环到 $k$时,内层有转移方程: $\color{Red}{dist[i,j]=min(dist[i,j],dist[i,k]+dist[k,j])}$.

#### 有向无环图描述表达式

若一个有向图中不存在环,则称为有向无环图,简称 $DAG$图.

![](https://cdn.acwing.com/media/article/image/2023/10/22/85276_db9e8b6070-20231022153623.png) 

将表达式转化为有向无环图步骤:

1. 把各个操作数不重复地排成一排;
2. 标出各个运算符的生效顺序(先后顺序有点出入无所谓);
3. 按顺序加入运算符,注意**分层**;
4. 从底向上逐层检查同层的运算符是否可以合体.

以`(a*b)*(a*b)*(a*b)*c`为例

* **第一步**:把各个操作数不重复地排成一排

![](https://cdn.acwing.com/media/article/image/2023/10/22/85276_e1e097d170-20231022154437.png) 

* **第二步**:标出各个运算符的生效顺序(先后顺序有点出入无所谓)

![](https://cdn.acwing.com/media/article/image/2023/10/22/85276_1709280270-20231022154607.png) 

* **第三步**:按顺序加入运算符,注意**分层**

![](https://cdn.acwing.com/media/article/image/2023/10/22/85276_6782a5da70-20231022154821.png) 

* **第四步**:从底向上逐层检查同层的运算符是否可以合体

![](https://cdn.acwing.com/media/article/image/2023/10/22/85276_9da2932a70-20231022154927.png) 

![](https://cdn.acwing.com/media/article/image/2023/10/22/85276_a0d42b6070-20231022154946.png) 

#### 拓扑排序

