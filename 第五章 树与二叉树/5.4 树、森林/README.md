#### 树的存储结构

* 双亲表示法

采用**一组连续空间**来存储每个结点,同时在**每个结点中增设一个伪指针**,指示其**双亲结点在数组中的位置**.根结点的下标为0,其伪指针域为-1.

![](https://cdn.acwing.com/media/article/image/2023/08/28/85276_9f4aefbf45-20230828150030.png) 

```cpp
#define MAX_TREE_SIZE 100
typedef int ElemType;

typedef struct{//树的结点定义
    ElemType data;//数据元素
    int parent;//双亲位置域
}PTNode;

typedef struct{
    PTNode nodes[MAX_TREE_SIZE];//双亲表示
    int size;//结点个数
}PTree;
```

查指定结点的**双亲**很方便,查指定结点的**孩子**不方便(只能**从头遍历**)

* 孩子表示法

将每个结点的孩子结点都用单链表链接起来形成一个线性结构,此时 $n$个结点就有 $n$个孩子链表(**叶子结点**的孩子链表为**空表**)

![](https://cdn.acwing.com/media/article/image/2023/08/28/85276_47ed668e45-20230828154818.png) 

```cpp
#define MAX_TREE_SIZE 100
typedef char ElemType;

struct ChildNode
{//链表中每个结点的定义
    //链表中每个结点存储的不是数据本身,而是数据在数组中存储的位置下标
    int child;//孩子结点在数组中的位置
    struct ChildNode *next;//下一个孩子
};

typedef struct
{//树中每个结点的定义
    ElemType data;
    ChildNode *firstchild;//孩子链表头指针
}CHNode;

typedef struct
{
    CHNode nodes[MAX_TREE_SIZE];
    int size;
}CTree;
```

孩子表示法这种存储方式**寻找子女的操作非常直接**,而**寻找双亲**的操作需要遍历 $n$个结点中孩子链表指针域所指向的 $n$个孩子链表.

* 孩子兄弟表示法(**使用较多**)

孩子兄弟表示法又称**二叉树表示法**,即以**二叉链表**作为树的存储结构.孩子兄弟表示法使每个结点包括三部分内容：结点值、**指向结点第一个孩子结点的指针**、**指向结点下一个兄弟结点的指针**（沿此域可以找到结点的所有兄弟结点）。

![](https://cdn.acwing.com/media/article/image/2023/08/28/85276_b120991f45-20230828155113.png) 

```cpp
#define MAX_TREE_SIZE 100
typedef char ElemType;

typedef struct CSNode
{
    ElemType data;
    struct CSNode *firstchild,*nextsibling;//第一个孩子和右兄弟节点
    //类似于二叉树中左孩子(第一个孩子),右孩子(右兄弟节点)
}CSNode,*CSTree;
```

孩子兄弟存储表示法比较灵活,其最大的**优点**是可以方便的**实现树转换为二叉树**的操作,易于**查找结点的孩子**等;**缺点**是从当前结点**查找其双亲结点**比较麻烦.

若为每一个结点增设一个 $parent$域指向其父结点,则查找结点的父结点也很方便.

通过孩子兄弟表示法,任意一棵普通树都可以相应转化为一棵二叉树,也就是说,任意一棵普通树都有唯一一颗二叉树与之对应;而森林通过**相邻树连边**变为大树,最后亦可转化为二叉树.

#### 树的遍历

树的遍历主要有**先根遍历**和**后根遍历**.

- 先根遍历:若树非空,则先访问根结点,再按照从左到右的顺序遍历根结点的每一棵子树.**这个访问顺序与这棵树对应的二叉树的`先序遍历顺序`相同**.
- 后根遍历:若树非空,则按照从左到右的顺序遍历根结点的每一棵子树,之后再访问根结点.**其访问顺序与这棵树对应的二叉树的`中序遍历`顺序相同**.
- 层次遍历:与二叉树的层次遍历思想基本相同,即按**层序依次访问**各结点.

#### 森林的遍历

* **先序遍历森林**

>   若森林为非空，则按如下规则进行遍历：
>
> （1）访问森林中**第一棵树**的根结点。
>
> （2）先序遍历第一棵树中根结点的子树森林。
>
> （3）先序遍历除去第一棵树之后剩余的树构成的森林。
>
> 对森林的先序遍历，效果等同于依次对各个树进行**先根**遍历，实质上，等同于依次对**二叉树的先序遍历**。
>
> ![](https://cdn.acwing.com/media/article/image/2023/08/28/85276_0377704d45-20230828171802.png) 
>
> 先序遍历结果为: $\color{Red}{BEKLFCGDHMIJ}$

* **中序遍历森林**

>  若森林为非空，则按如下规则进行遍历：
>
> （1）中序遍历森林中第一棵树的根结点的子树森林。
>
> （2）访问第一棵树的根结点。
>
> （3）中序遍历除去第一棵树之后剩余的树构成的森林。
>
> 对森林的先序遍历，效果等同于依次对各个树进行**后根**遍历，实质上，等同于依次对**二叉树的中序遍历**。
>
> 
> ![](https://cdn.acwing.com/media/article/image/2023/08/28/85276_0377704d45-20230828171802.png)
>
> 中序遍历结果为: $\color{Red}{KLEFBGCMHIJD}$

**总结**

![](https://cdn.acwing.com/media/article/image/2023/08/28/85276_7c85832d45-20230828172253.png) 



>  设森林 $F$中有 $3$棵树，第一、第二、第三棵树的结点个数分别为 $M_1$,  $M_2$和 $M_3$。与森林 $F$对应的二叉树根结点的右子树上的结点个数是().
>
> A. $M_1$
>
> B. $M_1+M_2$
>
> C. $M_3$
>
> D. $\color{Red}{M_2+M_3}$

设第一、第二、第三棵树的根结点分别为 $F_1$, $F_2$和 $F_3$,转化为二叉树为如下图所示:

![](https://cdn.acwing.com/media/article/image/2023/08/28/85276_70802e2a45-20230828173539.png) 

故森林 $F$对应的二叉树根结点为 $F_1$, $F_1$的右子树包含第二和第三棵树,故结点数为 $M_2+M_3$.

>  设 $F$是一个森林， $B$是由 $F$变换来的二叉树。若 $F$中有 $n$个非终端结点，则 $B$中右指针域为空的结点有()个。
>
> A. $n-1$
>
> B. $n$
>
> C. $\color{Red}{n+1}$
>
> D. $n+2$

根据森林转换为二叉树的“**左孩子右兄弟**”的表示法，即对于每棵二叉树，每个结点的**右指针**指向其**右邻兄弟**.

针对每一个非终端结点，一定会**有且仅有一个**孩子结点没有右邻兄弟，即右指针领域为空。因此 $n$个非终端结点，就有 $n$个右指针域为空。(**一对一**的关系)

看完单棵二叉树，再来看这些二叉树是怎么连接成一棵二叉树的。原理是：将后一棵二叉树的**根节点**作为前一棵二叉树的**右孩子**连接起来，所以只有`最后一棵二叉树的根结点`没有右孩子，即右指针域为空。

综上,故在 $B$中有 $n+1$个右指针域为空的结点.

>  某二叉树结点的中序序列为 $BDAECF$,后序序列为 $DBEFCA$,则该二叉树对应的森林包括()棵树.
>
> A. $1$
>
> B. $2$
>
> C. $\color{Red}{3}$
>
> D. $4$

通过二叉树的中序序列和后序序列可构造出如下左图所示,对应的森林如下右图所示,可看出有 $3$棵树.

![20230828175610.png](https://cdn.acwing.com/media/article/image/2023/08/28/85276_2535482145-20230828175610.png) 









#### 5.4.1



#### 5.4.2



#### 5.4.3



#### 5.4.4



#### 5.4.5



#### 5.4.6





#### 5.4.7

