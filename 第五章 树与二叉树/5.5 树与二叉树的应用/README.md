#### 哈夫曼树和哈夫曼编码

* 每个初始结点最终都成为叶结点，且**权值越小**的结点到根结点的**路径长度越大**;
* 构造过程中共新建 $n-1$个结点(**双分支结点(非叶子结点)**,每两个结点合并成一个),哈夫曼树的结点总数为 $n+n-1=2n-1$(**常考**);
* 哈夫曼树中不存在度为 $1$的结点;
* 哈夫曼树不唯一,但 $\displaystyle WPL=\sum_{i=1}^{n}w_i\times l_i$(其中 $w_i$表示第 $i$个叶节点所带的权值, $l_i$是该叶结点到根结点的路径长度(**经过的边**))必然相同且最优.

* 若没有一个编码是另一个编码的前缀,则称这样的编码为**前缀编码**.例如, $11$是 $1101$的前缀,故不满足前缀编码.

#### 并查集

在采用树的**双亲指针数组**表示作为并查集的存储表示时,集合元素的编号从 $0$到 $SIZE-1$,其中 $SIZE$是最大元素的个数.

```cpp
#define SIZE 110
int UFSets[SIZE];
```

* 并查集的初始化操作

```cpp
void Initial(int S[])//并查集的初始化
{
    for(int i=0;i<SIZE;i++)
        S[i]=-1;
}
```

* 并查集的查询操作,最坏时间复杂度为 $O(n)$

```cpp
int Find(int S[],int x)//并查集的查询操作(主要)
{
    while(S[x]>=0)//循环找到x的根
        x=S[x];
    return x;//根的S[]小于0
}
```

* 并查集的合并操作, $Union$函数时间复杂度为 $O(1)$

```cpp
void Union(int S[],int root1,int root2)//并查集的合并操作(主要)
{
    if(root1==root2)
        return ;
    S[root2]=root1;
}

void Join(int S[],int x,int y)//查询并合并操作
{
    int fx=Find(S,x),fy=Find(S,y);
    Union(S, fx, fy);
}
```

* 关于 $Union$操作的优化

用**根结点的绝对值**表示树的结点总数,让小树合并到大树.该方法构造的树高不超过 $\left \lfloor \log_2 n \right \rfloor+1$,当 $Union$操作优化后, $Find$操作最坏时间复杂度为 $O( \log _2 n)$.

```cpp
void Union_Optimize(int S[],int root1,int root2)//并查集的合并优化操作
{
    if(root1==root2)
        return ;
    if(S[root2]>S[root1])//root2所在树是小树,结点数少(注意是负数比较)
    {
        S[root1]+=S[root2];
        S[root2]=root1;
    }
    else//反之,roo1所在树是小树
    {
        S[root2]+=S[root1];
        S[root1]=root2;
    }
}

void Join(int S[],int x,int y)//查询并合并操作
{
    int fx=Find(S,x),fy=Find(S,y);
    //Union(S, fx, fy);
    Union_Optimize(S, fx, fy);
}
```

* 关于 $Find$操作的优化(路径压缩)

先找到根结点,再将查找路径上的所有节点都挂到根结点下.

```cpp
//非递归实现
int Find_Optimize(int S[],int x)//并查集的查询优化操作(主要)
{
    int root=x;
    while(S[root]>=0)//循环找到根
        root=S[root];
    while(x!=root)
    {
        int t=S[x];
        S[x]=root;
        x=t;
    }
    return root;
}

//递归实现
int Find_Optimize(int S[],int x)//并查集的查询优化操作(主要)
{
    if(S[x]>=0)
        return S[x]=Find_Optimize(S,S[x]);
    return x;
}
```

每次 $Find$操作,先找根,再**压缩路径**,可使树的高度不超过 $O(\alpha(n))$,其中 $\alpha(n)$是一个增长很缓慢的函数,对于常见的 $n$值,通常 $\alpha (n) \leq 4$,因此优化后并查集的 $Find$和 $Union$操作时间开销很低.

>  在有 $n$个叶结点的哈夫曼树中,非叶结点的总数是()
>
> A. $\color{Red}{n-1}$
>
> B. $n$
>
> C. $2n-1$
>
> D. $2n$

**套结论**:构造过程中共新建 $n-1$个结点(**双分支结点(非叶子结点)**,每两个结点合并成一个),哈夫曼树的结点总数为 $n+n-1=2n-1$(**常考**)

>  下列编码中,( $\color{Red}{B}$)不是前缀码.
>
> A. `{00,01,10,11}`
>
> B. `{0,1,00,11}`
>
> C. `{0,10,110,111}`
>
> D. `{10,110,1110,1111}`

若没有一个编码是另一个编码的前缀,则称这样的编码为**前缀编码**.在 $A,C,D$中均满足该条件,而在 $B$中, $0$是 $00$的前缀, $1$是 $11$的前缀,故不满足条件.

>  设哈夫曼编码的长度不超过 $4$，若已对两个字符编码为 $1$和 $01$，则还最多可对()个字符编码.
>
> A. $2$
>
> B. $3$
>
> C. $\color{Red}{4}$
>
> D. $5$

将该哈夫曼编码树构造出来,注意**一个编码不能是任何其他编码的前缀**.

![](https://cdn.acwing.com/media/article/image/2023/08/30/85276_f20eec6f47-20230830172311.png) 

其中 $01$和 $1$已使用,剩下 $4$种,分别是 $0000$, $0001$, $0010$, $0011$.

>  一棵哈夫曼树共有 $215$个结点，对其进行哈夫曼编码，共能得到()个不同的码字.
>
> A. $107$
>
> B. $\color{Red}{108}$
>
> C. $214$
>
> D. $215$

构造过程中共新建 $n-1$个结点(**双分支结点(非叶子结点)**,每两个结点合并成一个),哈夫曼树的结点总数为 $n+n-1=2n-1$(**常考**)

设码字(叶子结点)数为 $x$,已知总结点数为 $215$,即 $2\times x-1=215$,故结果为 $108$.

>  若度为 $m$的哈夫曼树中，叶子结点个数为 $n$,则非叶子结点的个数为().
>
> A. $n-1$
>
> B. $\left \lfloor \frac{n}{m} \right \rfloor -1$
>
> C. $\color{Red}{\left \lceil \frac{n-1}{m-1} \right \rceil}$
>
> D. $\left \lceil \frac{n}{m-1} \right \rceil -1$

设非叶子结点的个数为 $n_m$, $总结点数=n+n_m$;

边数(度数)贡献主要由非叶子结点产生,且`边数(度数)=总结点数-1`,故 $总结点数-1=n_m\times m$;

联立两式得: $n_m\times m+1=n+n_m$,故 $n_m=\frac{n-1}{m-1}$,此处上取整的原因是主要进行比较操作(多合一),存在余数时亦需要进行处理.

>  并查集中最核心的两个操作是:①查找,查找两个元素是否属于同一个集合;②合并,如果两个元素不属于同一个集合,且所在的两个集合互不相交,则合并这两个集合.假设初始长度为 $10(0\sim 9)$的并查集,按 $1-2$、 $3-4$、 $5-6$、 $7-8$、 $8-9$、 $1-8$、 $0-5$、 $1-9$的顺序进行查找和合并操作,最终并查集共有()个集合.
>
> A. $1$
>
> B. $2$
>
> C. $\color{Red}{3}$
>
> D. $4$ 